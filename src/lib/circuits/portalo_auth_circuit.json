{
  "noir_version": "0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c",
  "hash": 18221937056552327742,
  "abi": {
    "parameters": [
      {
        "name": "hashed_signature",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "profileId",
        "type": {
          "kind": "array",
          "length": 8,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "nonce",
        "type": {
          "kind": "array",
          "length": 8,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "hashed_encryption_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "47": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n",
      "path": "std/slice.nr"
    },
    "53": {
      "source": "use dep::std::ecdsa_secp256k1::verify_signature;\n\nfn main(\n  hashed_signature: [u8; 32],\n  profileId: pub [u8; 8],\n  nonce: pub [u8; 8], \n  hashed_encryption_key: pub [u8; 32]\n) {\n    let secret: [u8; 48] = hashed_signature.as_slice().append(profileId.as_slice()).append(nonce.as_slice()).as_array();\n\n    let hashed_secret = std::hash::sha256(secret);\n    assert(hashed_secret == hashed_encryption_key);\n}\n\n#[test]\nfn test_main() {\n    let signature = std::hash::sha256(\"0x1f5947fca12d9ab31bd573c83d40ce5e5d89f3d99e32ab5f4daccd0940aa5f114ec1917552ba1f66456bf6d0066ac0d6cd5b926bf6e1a16433eac77d1dead43a1b\".as_bytes()); \n    let profile_id: [u8; 8] = \"12345678\".as_bytes();\n    let nonce: [u8; 8] = \"12345678\".as_bytes();\n    \n    println(signature);\n    println(profile_id);\n    println(nonce);\n\n    let signature_as_slice = signature.as_slice();\n    let profile_id_as_slice = profile_id.as_slice();\n    let nonce_as_slice = nonce.as_slice();\n\n    let secret:[u8; 48] = signature_as_slice.append(profile_id_as_slice).append(nonce_as_slice).as_array();\n\n    let hashed_encryption_key = std::hash::sha256(secret);\n\n    println(hashed_encryption_key);\n\n    main(signature, profile_id, nonce, hashed_encryption_key);\n}",
      "path": "/home/pablo/Source/labs/eth-arg-hackathon-24/portalo_auth_circuit/src/main.nr"
    }
  },
  "names": ["main"]
}
